## DFS
> 탐색 알고리즘 중 하나인 Depth First Search 알고리즘에 대해 알아보자

<!-- TOC -->

- [DFS](#dfs)
- [DFS(깊이 우선 탐색)란?](#dfs깊이-우선-탐색란)
  - [DFS의 장단점](#dfs의-장단점)
- [DFS의 동작 과정](#dfs의-동작-과정)
- [DFS 예시 코드](#dfs-예시-코드)

<!-- /TOC -->

<br/>

## DFS(깊이 우선 탐색)란?

- 직관적이고 구현하기 쉬운 탐색 방법
- 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘

<br/>

### DFS의 장단점
- 장점
  - 코드가 직관적이고 구현이 쉽다
- 단점
  - 재귀함수를 이용하기 때문에 함수 호출 비용이 추가로 들어간다
  - 재귀 깊이가 지나치게 깊어지면 메모리 비용을 예측하기 어렵다
  - 최단 경로를 알 수 없다

<br/>

## DFS의 동작 과정

![dfs](https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif?20090326120256)

1. 탐색 시작 노드를 스택에 삽입하고 방문처리(`True`)
2. 스택 최상단 노드의 인접한 노드 중 방문처리가 되지 않은(`False`) 노드가 하나라도 있으면 
그 노드를 스택에 넣고 방문처리, 인접 노드가 모두 방문처리 됐다면(`True` 상태이면) 스택에서 최상단 노드를 꺼냄
   - 인접한 노드가 여러개라면 이 예제에서는 낮은 수부터 방문
1. 2번 과정을 수행할 수 없을 때까지 반복

> 깊이 우선으로 스택구조를 가지고 탐색하기 때문에 **재귀함수를 쓰면 편리하다!**

<br/>

## DFS 예시 코드

- 위 그래프의 dfs 동작과정을 코드로 구현하면 다음과 같다

```python
def dfs(graph, v, visited):

    # 방문처리
    visited[v] = True

    # 방문한 노드 확인하기 위해 출력
    print(v) # 1 2 7 6 8 3 4 5

    for i in graph[v]: 
        if not visited[i]: #인접한 노드가 방문처리되지 않았다면
            dfs(graph, i, visited) #탐색 반복

#그래프의 노드를 1부터 시작하여 가독성을 좋게 하기 위해 인덱스 0은 사용하지 않음
graph = [
    [],
    [2, 5, 9],
    [1, 3],
    [2, 4],
    [3],
    [1, 6, 8],
    [5, 7],
    [6],
    [5],
		[1, 10],
		[9]
]

#마찬가지로 코드의 가독성을 위해 그래프 리스트의 길이에 맞춰 방문처리 리스트 생성
visited = [False] * 9 
dfs(graph, 1, visited)
```



